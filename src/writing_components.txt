CSciBox is designed with the intention that you, the end user, have the ability 
to add further algorithms and computations as easily as possible. This file is a
short tutorial on how to do so. We assume that the reader is comfortable writing
small amounts of Python code, including the actual algorithm being implemented.

In order to add functionality to CSciBox, you will be adding an object called a
component. This is a self-contained section of processing that can be strung
together with other components to perform some overall task. Your component
needs to be in a .py file in the folder src/cscience/components. You should
import cscience.components in this file.

First, create a Python class that extends the class 
cscience.components.BaseComponent. This class should have a method, run_component,
that takes a 'core' object. This is the data that your algorithm will be
processing. So your file should now look something like:


import cscience.components

class MyComponent(cscience.components.BaseComponent):

    def run_component(self, core):
        ...
        
        
You can access the data in 'core' in two different ways. First, you can get
data from a specific depth, including the special depth (for data that applies
to the whole core) called 'all', using a standard Python dictionary access
(so core['all'] or core[depth]). You can also iterate through the data in the
core (getting all the non-all depths) using standard Python iteration
(for sample in core). In either case, the sample you obtain from the core will
function like a standard Python dictionary containing the data at that depth. 
You can then both access the data already stored in the sample and add new data
generated by your algorithm. The existing components have many examples of this
action, feel free to reference them. This method does not return anything,
rather, all results of your computation should be stored in the samples in the
core passed in originally. You do not need to worry about overwriting existing  
data within the dictionary; any overwritten data will be retained elsewhere.


Once you have created a component class and defined the run_component method,
your algorithm can be accessed from the main CSciBox app as usual (by adding the
component to a computation method and using that computation). However, there is
significant further support for your algorithm and user-friendliness available.
First, you can assign a name to your component that is more obvious (and less
restricted) than the class name. Do this by creating the class variable
'visible_name'; this will be the name shown for this component in the app. You
can also define the inputs to your algorithm. This will restrict the samples
returned by iterating through the core to only those depths that contain the
required values, so you do not need to check that the values are defined within
your algorithm. You can still access data at all depths of the core by indexing
a depth directly. Define your required attributes like this:

inputs = {'required':['required attribute 1', 'required attribute 2',...]}

You can also add an 'optional' key to the inputs dictionary with a second list
of attributes. These will not be used to restrict incoming data, but other parts
of the app will use this information to better communicate the function of your
component. Finally, you should define the outputs of your component. These are
defined as:

outputs = {'name of output': ('type', 'unit', has_error),
            ...}
            
'type' can be any of 'float', 'integer', 'string', or 'boolean'
'unit' is the default unit, if any of the result. Use a blank string if the
  output has no unit.
has_error is a boolean (True or False) indicating whether this value will have
  error bars.
  
You now have a fully-functional, user-friendly component ready to use within the
main CSciBox app. Read on for some advanced functionality you may wish to take
advantage of for some algorithms.


Adding Parameters
Many algorithms require some additional background data (such as a calibration
curve or a database of reservoir corrections) to function correctly. Rather than
hard-coding this background data, CSciBox strongly encourages you to take
advantage of our 'paleobase', where this data can be stored and passed
transparently to your algorithm (without you managing which version of the data
is being used). You can request background data for your component by defining
the 'params' class variable:

params = {'name of parameter':['required field 1', 'required field 2', ...]}

When a computation plan is built using your component, the user will be asked
to select a set of background data under the name of your parameter (eg
'calibration curve') and given a list of known data sets that contain the listed
required fields. Within your component, you can access this background data via:
self.paleobase['name of parameter'].


Preparing a Component
It is possible for the same component to be included in a computation method
multiple times. In general this makes no difference to how components should be 
written, as the surrounding application is designed to manage this possibility
seamlessly. However, for performance or clarity reasons, you may wish to perform
some setup outside the run_component method. In this case, you should define a
'prepare' method with the signature: 
def prepare(self, paleobase, workflow, experiment):
Please be sure to call super(MyComponent, self).prepare as this method does some
setup important for the rest of the component. After calling the superclass's
prepare method, you can perform any appropriate setup for your component. For
example, the Carbon-14 calibration component uses this method to parse the
calibration curve for more efficient lookup.


About UncertainQuantity
Rather than bare numbers, CSciBox makes an effort to retain both unit and error
information whenever possible. We do this using the UncertainQuantity object.
In general, you can perform any mathematical operations you would expect on an
UncertainQuantity without knowing any further details, and unit and error
information will be handled correctly automatically. However, this means you
cannot directly perform operations on a value with units and a value without.
Instead, you will need to create a new UncertainQuantity. You can import this
class from cscience.components, and create a new value via:
UncertainQuantity(value, 'unit', [error])
error may be a single value, for a symmetrical error, two values for a simple
asymmetrical error, or a Distribution object for an error defined by a probability
distribution.










